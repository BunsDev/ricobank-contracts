// SPDX-License-Identifier: AGPL-3.0-or-later
// copyright (c) 2023 the bank
pragma solidity 0.8.19;

import { Math } from '../../mixin/math.sol';
import { Flog } from '../../mixin/flog.sol';
import { Ward } from '../../../lib/feedbase/src/mixin/ward.sol';
import { Gem } from '../../../lib/gemfab/src/gem.sol';
import { Feedbase } from '../../../lib/feedbase/src/Feedbase.sol';

import { Hook } from '../hook.sol';

import { IUniswapV3Pool } from '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';
import { INonfungiblePositionManager } from './interfaces/INonfungiblePositionManager.sol';

interface IUniWrapper {
    function total(INonfungiblePositionManager nfpm, uint tokenId, uint160 sqrtPriceX96) view external returns (uint amount0, uint amount1);
    function computeAddress(address factory, address t0, address t1, uint24 fee) view external returns (address);
}

// hook for uni NonfungiblePositionManager
contract UniNFTHook is Hook, Ward, Flog, Math {
    IUniWrapper public wrap;
    struct Source {
        address fsrc;  // [obj] feedbase `src` address
        bytes32 ftag;  // [tag] feedbase `tag` bytes32
    }

    mapping (bytes32 ilk => mapping(address gem => Source source))   public sources;
    mapping (bytes32 ilk => mapping(address usr => uint[] tokenIds)) public inks;

    int256  internal constant  LOCK = 1;
    int256  internal constant  FREE = -1;
    uint256 public immutable ROOM;

    Feedbase       public feed;
    Gem            public rico;
    INonfungiblePositionManager public immutable nfpm;

    error ErrDinkLength();
    error ErrIdx();
    error ErrDir();
    error ErrFull();

    constructor(address _feed, address _rico, address _nfpm, uint _ROOM, address _wrap) {
        feed = Feedbase(_feed);
        rico = Gem(_rico);
        ROOM = _ROOM;
        nfpm = INonfungiblePositionManager(_nfpm);
        wrap = IUniWrapper(_wrap);
    }

    // autogenerated getter is only per-index
    function getInk(bytes32 i, address u) view external returns (uint[] memory) {
        return inks[i][u];
    }

    function frobhook(
        address sender,
        bytes32 ilk,
        address urn,
        bytes calldata dink,
        int  // dart
    ) _ward_ _flog_ external returns (bool safer) {
        if (dink.length < 32 || dink.length % 32 != 0) revert ErrDinkLength();
        int dir = int(uint(bytes32(dink[:32])));
        uint[] storage tokenIds = inks[ilk][urn];
        if (dir == LOCK) {
            // dink is an array of tokenIds
            for (uint i = 32; i < dink.length; i += 32) {
                // transfer position from user, record it in inks
                uint tokenId = uint(bytes32(dink[i:i+32]));
                nfpm.transferFrom(sender, address(this), tokenId);
                tokenIds.push(tokenId);
                if (tokenIds.length > ROOM) revert ErrFull();
            }
        } else if (dir == FREE) {
            // dink is an array of indexes into tokenIds
            if ((dink.length - 32) / 32 > tokenIds.length) revert ErrDinkLength();

            // move all of the outgoing tokenIds to the end of the array, then pop
            // swidx is index to swap next idx with
            // with possible exception of swidx == tokenIds.length - 1, in which
            // case idx == swidx,  tokenIds[swidx] does not need to be removed,
            // so it's always ok to swap with something that does need to be removed
            uint swidx = tokenIds.length;
            uint last = type(uint).max;
            for (uint i = dink.length - 32; i >= 32; i -= 32) {
                // tokenIds[swidx] is OOB or needs to be removed, so decrement swidx
                swidx--;

                uint idx = uint(bytes32(dink[i:i+32]));
                // removal indices must be in ascending order
                if (idx >= last || idx >= tokenIds.length) revert ErrIdx();
                // transfer position back to user
                nfpm.transferFrom(address(this), sender, tokenIds[idx]);
                tokenIds[idx] = tokenIds[swidx];
                last = idx;
            }

            // last elements of the list are all to be removed
            uint rm = tokenIds.length - swidx;
            while (rm > 0) {
                tokenIds.pop();
                unchecked {rm--;}
            }
        } else {
            revert ErrDir();
        }
        return dir == LOCK;
    }

    function grabhook(
        address vow,
        bytes32 ilk,
        address urn,
        uint256, // art
        uint256 bill,
        address keeper,
        uint256 rush,
        uint256 cut
    ) _ward_ _flog_ external {
        uint[] memory ids = inks[ilk][urn];
        delete inks[ilk][urn];
        // cut is RAD, rush is RAY, so vow earns a WAD
        uint256 earn = cut / rush;
        uint256 over = earn > bill ? earn - bill : 0;
        rico.transferFrom(keeper, vow, earn - over);
        rico.transferFrom(keeper, urn, over);

        uint len = ids.length;
        uint idx;
        while (true) {
            uint id = ids[idx];
            nfpm.transferFrom(address(this), keeper, id);
            unchecked{ idx++; }
            if (idx >= len) break;
        }
    }

    // respective amounts of token0 and token1 that this position
    // would yield if burned now
    function amounts(uint tokenId) view internal returns (
        address t0, address t1, uint a0, uint a1
    ) {
        uint24 fee;
        (,,t0,t1,fee,,,,,,,) = nfpm.positions(tokenId);

        // get the current price
        address pool = wrap.computeAddress(nfpm.factory(), t0, t1, fee);
        (uint160 sqrtPriceX96,,,,,,) = IUniswapV3Pool(pool).slot0();

        // uni library function to get amounts
        (a0, a1) = wrap.total(nfpm, tokenId, sqrtPriceX96);
    }

    function safehook(bytes32 ilk, address urn) public view returns (uint tot, uint minttl) {
        uint[] storage ink = inks[ilk][urn];
        minttl = type(uint).max;
        for (uint i = 0; i < ink.length; i++) {
            uint tokenId = ink[i];
            // get amounts of token0 and token1
            // multiply them by their prices in rico, add to tot
            (
                address token0, address token1, uint amount0, uint amount1
            ) = amounts(tokenId);
            {
                Source storage src0 = sources[ilk][token0];
                bytes32 val; uint ttl;
                if (src0.fsrc == address(0)) {
                    // if no feed, assume price is 0
                    // todo fail to frob tokens with no feed?
                    (val, ttl) = (0, type(uint).max);
                } else {
                    (val, ttl) = feed.pull(src0.fsrc, src0.ftag);
                }
                minttl = min(minttl, ttl);
                tot += amount0 * uint(val);
            }

            {
                Source storage src1 = sources[ilk][token1];
                bytes32 val; uint ttl;
                if (src1.fsrc == address(0)) {
                    (val, ttl) = (0, type(uint).max);
                } else {
                    (val, ttl) = feed.pull(src1.fsrc, src1.ftag);
                }
                minttl = min(minttl, ttl);
                tot += amount1 * uint(val);
            }
        }
    }

    function wire(bytes32 ilk, address gem, address fsrc, bytes32 ftag) _ward_ _flog_ external {
        sources[ilk][gem] = Source(fsrc, ftag);
    }

}
